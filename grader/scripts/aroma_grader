#!/usr/bin/env python
# -*- coding: latin-1 -*-
#
#   Copyright 2020 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
# $Author: frederic $
# $Date: 2016/07/11 14:50:43 $
# $Id: tidepool,v 1.28 2016/07/11 14:50:43 frederic Exp $
#
# -*- coding: utf-8 -*-

"""
A simple GUI for rating timecoursese by whatever metric you want
"""

from __future__ import print_function, division

from pyqtgraph.Qt import QtGui, QtCore

import pyqtgraph as pg
import numpy as np
import glob

import sys
import os
import argparse
import pandas as pd
from scipy import fftpack
import grader.LightboxItem as lb
import grader.io as io


hammingwindows = {}


def is_valid_dir(parser, arg):
    """
    Check if argument is existing file.
    """
    if not os.path.isdir(arg) and arg is not None:
        parser.error('The directory {0} does not exist!'.format(arg))

    return arg


def is_valid_file(parser, arg):
    """
    Check if argument is existing file.
    """
    if not os.path.isfile(arg) and arg is not None:
        parser.error('The file {0} does not exist!'.format(arg))

    return arg


def invert_float(parser, arg):
    """
    Check if argument is float or auto.
    """
    if arg != 'auto':
        try:
            arg = float(arg)
        except parser.error:
            parser.error('Value {0} is not a float or "auto"'.format(arg))

    if arg != 'auto':
        arg = 1.0 / arg
    return arg


def is_float(parser, arg):
    """
    Check if argument is float or auto.
    """
    if arg != 'auto':
        try:
            arg = float(arg)
        except parser.error:
            parser.error('Value {0} is not a float or "auto"'.format(arg))

    return arg

def findaromafiles(featdir, aromadir):
    icfile = os.path.join(aromadir, 'melodic_IC_thr_MNI2mm.nii.gz')
    icfile = os.path.join(aromadir, 'melodic.ica', 'melodic_IC.nii.gz')
    if not os.path.isfile(icfile):
        print('cannot find independent component file at', icfile)
        sys.exit()

    icmask = os.path.join(aromadir, 'melodic.ica', 'mask.nii.gz')
    if not os.path.isfile(icmask):
        print('cannot find independent component file at', icmask)
        sys.exit()

    bgfile = os.path.join(os.environ['FSLDIR'], 'data', 'standard', 'MNI152_T1_2mm.nii.gz')
    bgfile = os.path.join(featdir, 'reg', 'example_func.nii.gz')
    if not os.path.isfile(bgfile):
        print('cannot find background image file at', bgfile)
        sys.exit()

    funcfile = os.path.join(featdir, 'filtered_func_data.nii.gz')
    if not os.path.isfile(funcfile):
        print('cannot find functional data file at', funcfile)
        sys.exit()

    tcfile = os.path.join(aromadir, 'melodic.ica', 'melodic_Tmodes')
    if not os.path.isfile(tcfile):
        print('cannot find AROMA timecourse file at', tcfile)
        sys.exit()

    motionfile = os.path.join(featdir, 'mc', 'prefiltered_func_data_mcf.par')
    if not os.path.isfile(motionfile):
        print('cannot find motion parameter file at', motionfile)
        sys.exit()

    removefile = os.path.join(aromadir, 'classified_motion_ICs.txt')
    if not os.path.isfile(removefile):
        print('cannot find removed component file at', removefile)
        sys.exit()

    return icfile, icmask, bgfile, funcfile, tcfile, motionfile, removefile


def hamming(length, debug=False):
    #   return 0.54 - 0.46 * np.cos((np.arange(0.0, float(length), 1.0) / float(length)) * 2.0 * np.pi)
    r"""Returns a Hamming window function of the specified length.  Once calculated, windows
    are cached for speed.

    Parameters
    ----------
    length : int
        The length of the window function
        :param length:

    debug : boolean, optional
        When True, internal states of the function will be printed to help debugging.
        :param debug:

    Returns
    -------
    windowfunc : 1D float array
        The window function
    """
    try:
        return hammingwindows[str(length)]
    except KeyError:
        hammingwindows[str(length)] = 0.54 - 0.46 * np.cos(
            (np.arange(0.0, float(length), 1.0) / float(length)) * 2.0 * np.pi)
        if debug:
            print('initialized hamming window for length', length)
        return hammingwindows[str(length)]


def spectrum(inputdata, Fs=1.0, mode='power', trim=True):
    r"""Performs an FFT of the input data, and returns the frequency axis and spectrum
    of the input signal.

    Parameters
    ----------
    inputdata : 1D numpy array
        Input data
        :param inputdata:

    Fs : float, optional
        Sample rate in Hz.  Defaults to 1.0
        :param Fs:

    mode : {'real', 'imag', 'mag', 'phase', 'power'}, optional
        The type of spectrum to return.  Default is 'power'.
        :param mode:

    trim: bool
        If True (default) return only the positive frequency values

    Returns
    -------
    specaxis : 1D float array
        The frequency axis.

    specvals : 1D float array
        The spectral data.

    Other Parameters
    ----------------
    Fs : float
        Sample rate in Hz.  Defaults to 1.0
        :param Fs:

    mode : {'real', 'imag', 'complex', 'mag', 'phase', 'power'}
        The type of spectrum to return.  Legal values are 'real', 'imag', 'mag', 'phase', and 'power' (default)
        :param mode:
    """
    if trim:
        specvals = fftpack.fft(inputdata)[0:len(inputdata) // 2]
        maxfreq = Fs / 2.0
        specaxis = np.linspace(0.0, maxfreq, len(specvals), endpoint=False)
    else:
        specvals = fftpack.fft(inputdata)
        maxfreq = Fs
        specaxis = np.linspace(0.0, maxfreq, len(specvals), endpoint=False)
    if mode == 'real':
        specvals = specvals.real
    elif mode == 'imag':
        specvals = specvals.imag
    elif mode == 'complex':
        pass
    elif mode == 'mag':
        specvals = np.absolute(specvals)
    elif mode == 'phase':
        specvals = np.angle(specvals)
    elif mode == 'power':
        specvals = np.sqrt(np.absolute(specvals))
    else:
        print('illegal spectrum mode')
        specvals = None
    return specaxis, specvals


class KeyPressWindow(QtGui.QMainWindow):
    sigKeyPress = QtCore.pyqtSignal(object)
    sigResize = QtCore.pyqtSignal(object)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def keyPressEvent(self, ev):
        self.sigKeyPress.emit(ev)

    def resizeEvent(self, ev):
        self.sigResize.emit(ev)


def incrementgrade(whichfile):
    global alldata, namelist

    alldata[namelist[whichfile]]['grade'] += 1


def decrementgrade(whichfile):
    global alldata, namelist

    alldata[namelist[whichfile]]['grade'] -= 1


def writegrades():
    global alldata, namelist, numelements, outputfile

    with open(outputfile, 'w') as thefile:
        for i in range(len(namelist)):
            thefile.write('{0}, {1:d}, {2:f}\n'.format(namelist[i], alldata[namelist[i]]['grade'], alldata[namelist[i]]['samplerate']))


def windowResized(evt):
    global mainwin

    print('handling window resize')
    if mainwin is not None:
        updateLightbox()


def keyPressed(evt):
    global whichfile, numelements, mainwin

    if evt.key() == QtCore.Qt.Key_Up:
        incrementgrade(whichfile)
    elif evt.key() == QtCore.Qt.Key_Down:
        decrementgrade(whichfile)
    elif evt.key() == QtCore.Qt.Key_Left:
        whichfile = (whichfile - 1) % numelements
    elif evt.key() == QtCore.Qt.Key_Right:
        whichfile = (whichfile + 1) % numelements
    elif evt.key() == QtCore.Qt.Key_Escape:
        writegrades()
        print('done')
    else:
        print(evt.key())

    updateTimecourse()
    updateMotion()
    if mainwin is not None:
        updateLightbox()


def updateTimecourse():
    global timecourse_ax, spectrum_ax, whichfile, alldata, namelist, win, numelements
    thisfile = alldata[namelist[whichfile]]
    windowtitle = 'Grader - {0} ({1} of {2})'.format(namelist[whichfile], whichfile, numelements)
    win.setWindowTitle(windowtitle)

    if thisfile['grade'] is None:
        pencolor = 'w'
    elif thisfile['grade'] == 0:
        pencolor = 'w'
    elif thisfile['grade'] > 0:
        pencolor = 'g'
    else:
        pencolor = 'r'

    timecourse_ax.plot(thisfile['timeaxis'], thisfile['timecourse'],
                      stepMode=False, fillLevel=0, pen=pg.mkPen(pencolor, width=1), clear=True)

    if thisfile['grade'] is None:
        thelabel = 'Grade: None'
    else:
        thelabel = 'Grade: {0}'.format(thisfile['grade'])

    spectrum_ax.plot(thisfile['freqaxis'], thisfile['spectrum'],
                     name=thelabel,
                     stepMode=False,
                     fillLevel=0,
                     pen=pg.mkPen(pencolor, width=1),
                     clear=True)

    spectop = 1.25 * np.max(thisfile['spectrum'])
    spectrum_ax.setYRange(0.0, spectop, padding=0)


    #text = pg.TextItem(text=thelabel,
    #                   anchor = (0.0, 1.0),
    #                   angle = 0,
    #                   fill = (0, 0, 0, 100))
    #spectrum_ax.addItem(text)
    spectrum_ax.addLegend(offset=(0.75 * thisfile['freqaxis'][-1], 0.75 * np.max(thisfile['spectrum'])))


def updateMotion():
    global transmot_ax, rotmot_ax, whichfile, alldata, motion, namelist, win, numelements
    thisfile = alldata[namelist[whichfile]]
    curve1 = transmot_ax.plot()
    curve1.setData(thisfile['timeaxis'], motion['xtrans'],
                      stepMode=False, fillLevel=0, pen=pg.mkPen('FF8888', width=1), clear=True, name='xtrans')
    curve2 = transmot_ax.plot()
    curve2.setData(thisfile['timeaxis'], motion['ytrans'],
                      stepMode=False, fillLevel=0, pen=pg.mkPen('88FF88', width=1), clear=True, name='ytrans')
    curve3 = transmot_ax.plot()
    curve3.setData(thisfile['timeaxis'], motion['ztrans'],
                      stepMode=False, fillLevel=0, pen=pg.mkPen('8888FF', width=1), clear=True, name='ztrans')
    transmot_ax.addLegend(offset=(0.75 * motion['maxtime'], 0.75 * motion['maxtrans']))

    curve4 = rotmot_ax.plot()
    curve4.setData(thisfile['timeaxis'], motion['xrot'],
                      stepMode=False, fillLevel=0, pen=pg.mkPen('FF8888', width=1), clear=True, name='xrot')
    curve5 = rotmot_ax.plot()
    curve5.setData(thisfile['timeaxis'], motion['yrot'],
                      stepMode=False, fillLevel=0, pen=pg.mkPen('88FF88', width=1), clear=True, name='yrot')
    curve6 = rotmot_ax.plot()
    curve6.setData(thisfile['timeaxis'], motion['zrot'],
                      stepMode=False, fillLevel=0, pen=pg.mkPen('8888FF', width=1), clear=True, name='ztrans')
    rotmot_ax.addLegend(offset=(0.75 * motion['maxtime'], 0.75 * motion['maxrot']))


def updateLightbox():
    global hist
    global currentdataset
    global maps
    global panetomap
    global ui
    global mainwin
    global currentloc
    global xdim, ydim, zdim
    global overlays
    global imagadj
    global whichfile

    mainwin.setTpos(whichfile)
    mainwin.updateAllViews()


def main():
    global ui, win
    global namelist, outputfile, alldata, motion, whichfile, numelements
    global mainwin

    mainwin = None

    parser = argparse.ArgumentParser(description='A program to review (and alter) AROMA component selections.')
    parser.add_argument(
        'featdir',
        type=lambda x: is_valid_dir(parser, x),
        help='Reopen a previously opened grader session output file.',
        default=None)
    parser.add_argument(
        '--aromadir',
        type=lambda x: is_valid_dir(parser, x),
        help='The location of the AROMA directory (if it is not at $FEATDIR/ICA_AROMA).',
        default=None)
    parser.add_argument(
        '--outputfile',
        type=str,
        help='The name of the new component file (if not specified, it will be put in the AROMA directory).',
        default=None)

    args = parser.parse_args()

    if args.aromadir is None:
        args.aromadir = os.path.join(args.featdir, 'ICA_AROMA')

    runmode = 'aroma'

    aromaICfile, aromaICmask, aromaBGfile, aromaFuncfile, aromaTCfile, aromaMotionfile, aromaRemovefile = findaromafiles(args.featdir, args.aromadir)

    if args.outputfile is None:
        args.outputfile = aromaRemovefile.replace('.txt','_revised.txt')


    print(aromaICfile)
    print(aromaICmask)
    print(aromaBGfile)
    print(aromaFuncfile)
    print(aromaTCfile)
    print(aromaMotionfile)
    print(aromaRemovefile)

    # set the sample rate
    tr, timepoints = io.fmritimeinfo(aromaFuncfile)
    samplerate = 1.0 / tr

    outputfile = args.outputfile

    # read in the timecourses and their current labels
    print('reading data...')
    alldata = {}
    numelements = 0
    alltcs = io.readvecs(aromaTCfile)
    numelements = alltcs.shape[0]
    grades = np.zeros(numelements, dtype=np.int)
    with open(aromaRemovefile, 'r') as thefile:
        inline = thefile.readline()
    inlist = inline.split(',')
    for component in inlist:
        grades[int(component) - 1] = -1

    # read in the motion timecourses
    allmotion = io.readvecs(aromaMotionfile)
    motion = {}
    motion['xtrans'] = allmotion[3, :] * 1.0
    motion['ytrans'] = allmotion[4, :] * 1.0
    motion['ztrans'] = allmotion[5, :] * 1.0
    motion['maxtrans'] = np.max([np.max(motion['xtrans']), np.max(motion['ytrans']), np.max(motion['ztrans'])])
    motion['mintrans'] = np.min([np.min(motion['xtrans']), np.min(motion['ytrans']), np.min(motion['ztrans'])])
    motion['xrot'] = allmotion[0, :] * 1.0
    motion['yrot'] = allmotion[1, :] * 1.0
    motion['zrot'] = allmotion[2, :] * 1.0
    motion['maxrot'] = np.max([np.max(motion['xrot']), np.max(motion['yrot']), np.max(motion['zrot'])])
    motion['minrot'] = np.min([np.min(motion['xrot']), np.min(motion['yrot']), np.min(motion['zrot'])])

    namelist = []
    for idx in range(numelements):
        thefile = str(idx)
        namelist.append(thefile)
        thegrade = grades[idx]
        thesamplerate = samplerate
        alldata[thefile] = {}
        invec = alltcs[idx, :]
        alldata[thefile]['timecourse'] = invec * 1.0
        alldata[thefile]['timeaxis'] = np.linspace(0.0, 1.0 * (len(invec) - 1), num=len(invec), endpoint=True) / thesamplerate
        alldata[thefile]['freqaxis'], alldata[thefile]['spectrum'] = \
            spectrum(hamming(len(invec)) * invec, Fs=thesamplerate, mode='power')
        alldata[thefile]['grade'] = thegrade
        alldata[thefile]['samplerate'] = thesamplerate
        print(thefile, thegrade, thesamplerate)
    print('Read in', numelements, 'files')
    motion['maxtime'] = alldata['0']['timeaxis'][-1] + 0.0
    whichfile = 0


    # make the main window
    if runmode == 'timecourse':
        import grader.graderTemplate as uiTemplate
    elif runmode == 'aroma':
        import grader.aromaviewTemplate as uiTemplate
    else:
        print('illegal runmode')
        sys.exit()

    app = QtGui.QApplication([])
    print("setting up output window")
    #win = QtGui.QMainWindow()
    win = KeyPressWindow()
    win.sigKeyPress.connect(keyPressed)
    win.sigResize.connect(windowResized)

    ui = uiTemplate.Ui_MainWindow()
    ui.setupUi(win)
    win.show()
    win.setWindowTitle("Grader")

    # set up the regressor timecourse window
    print('about to set up the timecourse')
    global timecourse_ax
    timecoursewin = ui.timecourse_graphicsView
    timecourse_ax = timecoursewin.addPlot()

    # set up the regressor spectrum window
    print('about to set up the spectrum')
    global spectrum_ax
    spectrumwin = ui.spectrum_graphicsView
    spectrum_ax = spectrumwin.addPlot()

    global transmot_ax, rotmot_ax
    if runmode == 'aroma':
        # set up the translational motion window
        print('about to set up the translational motion')
        transmotwin = ui.translation_graphicsView
        transmot_ax = transmotwin.addPlot()

        # set up the translational motion window
        print('about to set up the translational motion')
        rotmotwin = ui.rotation_graphicsView
        rotmot_ax = rotmotwin.addPlot()
    elif runmode == 'timecourse':
        transmot_ax = None
        rotmot_ax = None
    else:
        transmot_ax = None
        rotmot_ax = None

    updateTimecourse()
    updateMotion()

    if runmode == 'aroma':
        thresh = 0.5
        print('setting up image window')
        maskimage = lb.imagedataset('ICmask', aromaICmask, 'ICmask', lut_state=lb.mask_state)
        fgimage = lb.imagedataset('IC', aromaICfile, 'IC', lut_state=lb.ry_blb_state, mask=maskimage.data)
        #maskimage = fgimage.data * 1.0
        #maskimage[np.where(np.fabs(maskimage) < thresh)] = 0
        #fgimage.setMask(maskimage)
        bgimage = lb.imagedataset('BG', aromaBGfile, 'background', lut_state=lb.viridis_state)
        mainwin = lb.LightboxItem(fgimage, ui.image_graphicsView, bgmap=bgimage)
        updateLightbox()


    # wire up keystrokes to control interface


    QtGui.QApplication.instance().exec_()


if __name__ == "__main__":
    main()
